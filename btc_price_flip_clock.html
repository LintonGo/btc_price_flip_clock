
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BTC 机械翻页时钟</title>
    <!-- 引入 FlipClock CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/flipclock/0.7.8/flipclock.css">
    <style>
        /* === 1. 页面基础布局 === */
        body {
            background-color: #111;
            margin: 0;
            padding: 0;
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif;
            background: radial-gradient(circle at center, #222 0%, #000 100%);
        }
        /* 标题样式 */
        h1 {
            position: absolute;
            top: 5%;
            width: 100%;
            text-align: center;
            color: #888;
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 1px;
            margin: 0;
            z-index: 10;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        /* 底部文字样式 */
        .footer {
            position: absolute;
            bottom: 3%;
            width: 100%;
            text-align: center;
            color: #444;
            font-size: 12px;
            z-index: 10;
        }
        /* === 2. 外层容器：负责缩放 === */
        .scale-wrapper {
            /* 缩放中心点设为屏幕中心 */
            transform-origin: center center;
            /* 关键：display: inline-block 让容器仅包裹时钟内容，不撑满全屏 */
            display: inline-block;
        }
        /* === 3. 内层容器：负责翻页动画 === */
        .anim-wrapper {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* 强制隐藏标签 */
        .flip-clock-label {
            display: none !important;
        }
        /* 调整间隔符样式 */
        .flip-clock-divider {
            height: 100%;
            width: 15px !important;
        }
        .flip-clock-dot {
            background-color: #444;
            width: 12px;
            height: 12px;
            left: 1.5px;
        }
        .flip-clock-dot.top { top: 35%; }
        .flip-clock-dot.bottom { bottom: 35%; }
        /* === 修复：禁止单个数字内部动画 === */
        .flip-clock-card .flip-clock-top,
        .flip-clock-card .flip-clock-bottom,
        .flip-clock-card .flip-clock-flap,
        .flip-clock-card .flip-clock-flap .top,
        .flip-clock-card .flip-clock-flap .bottom,
        .flip-clock-card .flip-clock-leaf {
            transition: none !important;
            animation: none !important;
        }
        /* === 整体翻页动画 === */
        @keyframes flipInEffect {
            0% {
                transform: perspective(1000px) rotateX(-90deg);
                opacity: 0;
            }
            100% {
                transform: perspective(1000px) rotateX(0deg);
                opacity: 1;
            }
        }
        .animate-flip-in {
            animation: flipInEffect 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) forwards;
        }
        /* === 手机横屏适配 === */
        @media screen and (orientation: landscape) {
            h1, .footer {
                display: none !important;
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <h1>BTC / USD</h1>
    <!-- 双层结构 -->
    <div class="scale-wrapper">
        <div class="anim-wrapper">
            <div class="clock" style="margin: 0;"></div>
        </div>
    </div>
    <div class="footer"><span id="status">连接中...</span></div>
    <!-- 引入 jQuery 和 FlipClock JS -->
    <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/flipclock/0.7.8/flipclock.min.js"></script>
    <script>
        $(document).ready(function() {
            var clock = null;
            var $clockContainer = $('.clock');
            var $animWrapper = $('.anim-wrapper');
            var $scaleWrapper = $('.scale-wrapper');
            // 自动缩放函数 (统一逻辑：横竖屏都完全适配)
            function autoScaleClock() {
                var isLandscape = window.innerWidth > window.innerHeight;
                var scaleValue = 1;
                // 获取时钟当前的实际像素尺寸
                var currentHeight = $clockContainer.height();
                var currentWidth = $clockContainer.width();
                // 确保尺寸已加载
                if (currentHeight > 0 && currentWidth > 0) {
                    // 设定目标占用比例：横屏占满 95%，竖屏占满 80%
                    // 宽度统一占满 95% (防止溢出屏幕)
                    var targetHeight = isLandscape ? (window.innerHeight * 0.95) : (window.innerHeight * 0.8);
                    var targetWidth = window.innerWidth * 0.95;
                    // 1. 基于高度计算缩放
                    var scaleByHeight = targetHeight / currentHeight;
                    // 2. 基于宽度计算缩放
                    var scaleByWidth = targetWidth / currentWidth;
                    // 3. 取最小值 (Math.min)，保证不溢出屏幕，且完整显示所有数字
                    scaleValue = Math.min(scaleByHeight, scaleByWidth);
                    console.log(isLandscape ? "横屏" : "竖屏", "缩放比例:", scaleValue.toFixed(2));
                }
                $scaleWrapper.css('transform', 'scale(' + scaleValue + ')');
            }
            // 完全重建时钟（用于初始化或大间隔刷新）
            function renderClock(priceValue) {
                var targetPrice = Math.floor(priceValue);
                console.log('完全重建时钟:', targetPrice);
                // 1. 清理旧时钟
                if (clock) {
                    try {
                        clock.stop();
                        clock.destroy();
                    } catch(e) {}
                    $clockContainer.empty();
                }
                // 2. 准备动画
                $animWrapper.removeClass('animate-flip-in');
                void $animWrapper[0].offsetWidth;
                // 3. 创建新时钟
                clock = $clockContainer.FlipClock(targetPrice, {
                    clockFace: 'Counter',
                    autoStart: false
                });
                // 4. 执行翻页动画
                $animWrapper.addClass('animate-flip-in');
                // 5. 立即计算缩放，并延时再次确认（确保动画期间不错位）
                autoScaleClock();
                setTimeout(autoScaleClock, 650);
            }

            // 顺滑翻页更新（用于小间隔更新）
            function smoothUpdatePrice(priceValue) {
                if (!clock) {
                    renderClock(priceValue);
                    return;
                }
                var targetPrice = Math.floor(priceValue);
                console.log('顺滑翻页更新:', targetPrice);
                // 使用 FlipClock 原生的 setValue 方法，会自动翻页
                clock.setValue(targetPrice);
            }
            // WebSocket 连接变量
            var ws = null;
            var reconnectTimer = null;
            var $status = $('#status');

            // 节流控制变量
            var lastRenderTime = 0;
            var lastRenderedPrice = 0;
            var UPDATE_INTERVAL = 5000; // 5秒更新一次
            var USE_SMOOTH_FLIP = UPDATE_INTERVAL < 30000; // 小于30秒用顺滑翻页，否则用重建

            // 渲染时钟（带节流）
            function throttledRenderClock(priceValue) {
                var now = Date.now();
                var targetPrice = Math.floor(priceValue);

                // 只有价格变化且距离上次更新超过间隔时间才更新
                if (targetPrice !== lastRenderedPrice && (now - lastRenderTime >= UPDATE_INTERVAL)) {
                    lastRenderTime = now;
                    lastRenderedPrice = targetPrice;

                    // 根据间隔选择更新方式
                    if (USE_SMOOTH_FLIP) {
                        // 小间隔：使用顺滑翻页
                        smoothUpdatePrice(priceValue);
                    } else {
                        // 大间隔：使用完全重建
                        renderClock(priceValue);
                    }
                }
            }

            // 更新连接状态
            function updateStatus(status, isConnected) {
                $status.text(status);
                $status.css('color', isConnected ? '#4caf50' : '#888');
            }

            // 建立 WebSocket 连接
            function connectWebSocket() {
                if (ws) {
                    ws.close();
                }

                // Binance WebSocket 端点 - 实时推送 BTC/USDT 价格
                // 使用端口 443 以避免防火墙阻挡
                ws = new WebSocket('wss://stream.binance.me:9443/ws/btcusdt@ticker');

                ws.onopen = function() {
                    console.log('WebSocket 已连接');
                    updateStatus('实时更新中', true);
                    // 清除重连定时器
                    if (reconnectTimer) {
                        clearTimeout(reconnectTimer);
                        reconnectTimer = null;
                    }
                };

                ws.onmessage = function(event) {
                    try {
                        var data = JSON.parse(event.data);
                        // Binance ticker 返回的价格在 'c' 字段 (current price)
                        var price = parseFloat(data.c);
                        // 使用节流函数更新
                        throttledRenderClock(price);
                    } catch (e) {
                        console.error('解析 WebSocket 消息失败:', e);
                    }
                };

                ws.onerror = function(error) {
                    console.error('WebSocket 错误:', error);
                    updateStatus('连接错误', false);
                };

                ws.onclose = function() {
                    console.log('WebSocket 连接关闭');
                    updateStatus('重新连接中...', false);
                    // 5秒后尝试重连
                    reconnectTimer = setTimeout(connectWebSocket, 5000);
                };
            }

            // 初始化
            // 先用 HTTP 请求获取初始价格，避免等待 WebSocket 连接
            $.ajax({
                url: 'https://api.binance.me/api/v3/ticker/price?symbol=BTCUSDT',
                type: 'GET',
                dataType: 'json',
                success: function(data) {
                    var price = parseFloat(data.price);
                    renderClock(price);
                    // 重置节流时间
                    lastRenderTime = Date.now();
                    lastRenderedPrice = Math.floor(price);
                    // 建立 WebSocket 连接
                    connectWebSocket();
                },
                error: function(error) {
                    console.log('初始获取价格失败，直接连接 WebSocket:', error);
                    connectWebSocket();
                }
            });

            // 监听窗口大小变化
            $(window).on('resize', autoScaleClock);
        });
    </script>
</body>
</html>
